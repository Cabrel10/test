OpenSS7 Linux Fast STREAMS -- things to do.  2006-07-09
Copyright (c) 2001-2006  OpenSS7 Corporation.  <http://www.openss7.com/>
Copyright (c) 1997-2000  Brian Bidulock <bidulock@openss7.org>
See the end for copying conditions (for this file).

Things to do:

- Add a tail padding amount to the stream head as a option to facilitate
  conversion of mblks to sk_bufs.

  DONE: Implemented as SO_WRPAD.

- Socket buffer handling:

  1. Rather than write offset and padding, why not provide a flag (e.g.
     SO_SKBUFF) to indicate to the stream head to allocate an sk_buff
     with the message block and share buffers between mblk and sk_buff,
     then, the sk_buff can be used without allocation in the bottom
     half.  esballoc() and alloc_skbuff() can be used to set up the
     message block.  dup() could be made aware of the hidden sk_buff and
     increment the shared sk_buff count as well.  Also, msgpullup() and
     pullupmsg() could be made aware of message blocks containing
     sk_buffs and have them do the appropriate thing.

  2. The other thing that is needed is some way to tell the other end of
     a loopback connection that the sk_buff it has received already has
     an mblk attached to it as above.  Then the message block could be
     simply passed upstream and one would not need to be esballoc'ed for
     it.

  3. Another thing is to provide the ability to partial checksum and
     copy data from user into these sk_buffs, but setting an SO_CSUM
     flag along with the SO_SKBUFF flag to indicate the type of checksum
     to perform.

  The combination of the above three items should provide some serious
  performance gains for Linux networking based stream heads.

  TODO: Implement these three items.

- Had another look at specfs, devfs and udev.  It looks like we can
  create minor device nodes within /dev (not just /dev/streams) using
  devfs or udev.  Again, this doesn't do everything that specfs does.
  specfs will demand load when an attempt is made to open a non-existent
  character device.  Nevertheless, we can describe a "streams" class for
  udev and when a module registers a minor device node, we can have udev
  create that device node and provide permissions by adding our files to
  the /etc/udev/rules.d and /etc/udev/permissions.d directories.

  Therefore, on a udev system, we should make strconf-sh create the
  necessary rules.d and permissions.d file entries.  register_strnod
  will be modified to create a udev instance within the stream class
  matching the rules.d and permissions.d entry when creating a minor
  device node within the specfs.

  On a devfs system, register_strdev and register_strnod should perform
  devfs calls instead of calling register_chrdev.  That way minor device
  nodes will automagically appear at least once the module is loaded.

  TODO: rationalize specfs to devfs and udev

- Have the STREAMS subsystem register a panic notifier on 2.6 kernels to
  be able to recover from panics caused by misbehaving STREAMS modules
  or drivers.

  TODO: Register panic notifier.

- Per cpu data:- I am still using the older approach of using cacheline
  aligned arrays for per-cpu data.  This, of course, does not fully
  utilize NUMA architectures.  For NUMA architectures we need to use the
  per-cpu utilities provided by the 2.6 kernel.  I haven't touched
  converting this yet.

  Also, there are several NUMA supporting STREAMS utility functions
  (allocb_node, etc.) that need to be supported yet.

  TODO: Convert cacheline aligned arrays to NUMA per-cpu data on 2.6
        kernels.  Complete NUMA supporting STREAMS facilities.

- Timers and Buffer callbacks:- Still haven't tested these.

  TODO: Test.

- More performance testing and profiling on SMP.  On the same kernel
  running non-SMP we get pipe performance of about 80-90% of a Linux
  native pipe.  Just running an SMP kernel drops this to 60%
  comparative.  Running both CPUs in an SMP kernel does not improve
  matters.  Need to profile this up 80-90% on SMP too.  Also, so many
  changes were made for 64bit and 32bit compatibility that the old
  profiling information is out of date and needs to be updated.

  DONE: Profile and performance tests on SMP.

- I am interested to convert the perftest program to use a FIFO instead
  of a pipe.  This is because a FIFO is more closely related to a Linux
  Native pipe (i.e it has a read side and a write side, is really only
  one file pointer, and only supports unidirectional flow).  Comparative
  tests as opposed to STREAMS-based pipes should be interesting.

  DONE: Tested.  Results were unimpressive.  STREAMS FIFOs perform about
        1% better than STREAMS-based pipes.

- 32bit compatibility:- Not done yet, but a plan in place.  Override
  stupid CDROM ioctl conversions on kernels before 2.6.11, use
  compat_ioctl after that.  For the older read/write interface it will
  be necessary to have two "magic" lengths: one the same as the old one
  for 32-bit and a new 64-bit "magic" length.  This is so that the
  internal function can convert.  Perhaps it can really be the same
  number in the lower 32-bits.  Note that on later kernels there is a
  CONFIG_COMPAT define that we might want to check in the configure
  script.

  DONE: Tested on x86_64 with i686.
  DONE: Documentation of new registration functions.

- SMP:- Finally got at least a Hyper-Threaded Intel 630 for testing.
  There are some issues discovered when running the test suites.
  Initial debugging is done (everything runs and doesn't crash) it is
  just that some multiple writers and readers are getting stuck in wait
  queues.  What we need to do is to split the wait queues into open,
  close, read, write and ioctl from the big wait queue that it is, and
  largely get rid of the RSLEEP, WSLEEP, IOCWAIT type bits (we could
  still set them for compatibilty with SVR4 but not examine them).

  DONE: Tested on X86_64 SMP.

- 64bit clean:- Pretty good now.  I have clean compiles and test suite
  runs on 2.6.9-22.EL x86_64 kernels.

  DONE: Tested on x86_64.

- LiS Binary Compatibiility:-  Pretty much messed up right now.  I have
  the regparm(0) stuff on the callout and callback functions, and the
  STREAMS Compatibility Modules does regparm(0) on all the lis_
  functions.  Primary STREAMS data structures align on the first portion
  of the data structure.  Sizes vary, so don't do q+1.  Flags are a
  little different.  There are however several problematic data
  structures: cred_t and the ioctypes: iocblk, copyreq, copyresp, and
  the linkblk.  When you enable binary compatibility mode, it uses the
  LiS versions of these.

  DONE: Needs testing.

- LfS Binary Compatibility:-  A little better.  Callouts and callbacks
  always regparm(0).  STREAMS utility functions are always regparm(3).
  Data structures are stable for the most part.  cred_t, however, is
  variable depending on the kernel.  Compile with the LiS binary
  compatibility and the cred_t will be fixed size.

  DONE: Needs testing.

- Finish the documentation.

  MOSTLY DONE: updated documentation alot.

- Finish the full STREAMS logger and proper implementation of the
  strlog() utility.

  DONE: Added to strutil package.  Needs testing.

- Need to rework the specfs.  There are now several situations to
  consider:

  The following four situations require the specfs.

  a) 2.4 kernel without devfs
  b) 2.6 kernel without devfs
  c) 2.4 kernel with devfs but without devfsd
  d) 2.6 kernel with devfs but without devfsd

  The following two situations could use devfs instead of specfs.

  e) 2.4 kernel with devfs and with devfsd
  f) 2.6 kernel with devfs and with devfsd

  The following one situation could use udev instead of devfs or specfs.

  g) 2.6 kernel with udev

  To get this to work requires that there be an independent layer
  between the filesystem providing device access for STREAMS and the
  STREAMS subsystem.  A set of registration functions need to be
  provided and a common set of callouts from the filesystem made to the
  STREAMS executive.

  The registration functions need to be called when a STREAMS driver
  loads and the filesystem needs to do the right thing.  This also needs
  to include the registration of major and minor devices, including
  clone devices.

  The callout functions from the filesystem need to invoke the STREAMS
  device file operations in a predictable manner, and the STREAMS
  subsystem requires the ability to chain open calls, or even open
  STREAMS devices from within the kernel (e.g. for pipes and connld and
  such).

  It is difficult to get the filesystem (specfs, devfs, udev) to hold
  data structures in a manner that is also usable by the STREAMS
  subsystem, so the filesystem adaptation layer needs to maintain data
  structures in the same manner for all filesystems.

  Well,...  After a little investigation, it is all messed up.  udev
  doesn't do what we need when demand loading pseudo devices, and devfs
  is probably not used anymore (I found most production kernels disabled
  for devfs) so it looks like spefs is the way to go.  I might use udev
  for "real" device drivers, but that's just for SS7.  So it looks like
  we are stuck with mounting the specfs.  I notice that ptys still use
  their own filesystem too...

  So, what we need now is to rework data structures and the specfs to be
  a little more stable.

  DONE: Tested.

- Kernel objects are another thing.  For 2.6 kernels, we need to hold
  our data structures in the kobject manner so that the /sys filesystem
  is usable.  This requires another adaptation layer because 2.4 kernels
  do this in a completely different way.  Much of our /proc filesystem
  stuff needs to move into /sys for 2.6 kernels by stay the same for 2.4
  kernels.

  The /sys filesystem does not really do much for STREAMS.  The
  /dev/streams specfs filesystem does more for us.

  SKIPPED.

=========================================================================

Copyright (c) 2001-2006  OpenSS7 Corporation. <http://www.openss7.com/>
Copyright (c) 1997-2000  Brian Bidulock <bidulock@openss7.org>

All Rights Reserved.

 Permission is granted to make and distribute verbatim copies of this
 manual provided the copyright notice and this permission notice are
 preserved on all copies.

 Permission is granted to copy and distribute modified versions of this
 manual under the conditions for verbatim copying, provided that the
 entire resulting derived work is distributed under the terms of a
 permission notice identical to this one

 Since the Linux kernel and libraries are constantly changing, this
 manual page may be incorrect or out-of-date.  The author(s) assume no
 responsibility for errors or omissions, or for damages resulting from
 the use of the information contained herein.  The author(s) may not
 have taken the same level of care in the production of this manual,
 which is licensed free of charge, as they might when working
 professionally.

 Formatted or processed versions of this manual, if unaccompanied by
 the source, must acknowledge the copyright and authors of this work.

-------------------------------------------------------------------------

 U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software
 on behalf of the U.S. Government ("Government"), the following
 provisions apply to you.  If the Software is supplied by the Department
 of Defense ("DoD"), it is classified as "Commercial Computer Software"
 under paragraph 252.227-7014 of the DoD Supplement to the Federal
 Acquisition Regulations ("DFARS") (or any successor regulations) and the
 Government is acquiring only the license rights granted herein (the
 license rights customarily provided to non-Government users).  If the
 Software is supplied to any unit or agency of the Government other than
 DoD, it is classified as "Restricted Computer Software" and the
 Government's rights in the Software are defined in paragraph 52.227-19
 of the Federal Acquisition Regulations ("FAR") (or any successor
 regulations) or, in the cases of NASA, in paragraph 18.52.227-86 of the
 NASA Supplement to the FAR (or any successor regulations).

=========================================================================

 Commercial licensing and support of this software is available from
 OpenSS7 Corporation at a fee.  See http://www.openss7.com/

=========================================================================
vim: tw=72 nocindent fo=tcqlorn
