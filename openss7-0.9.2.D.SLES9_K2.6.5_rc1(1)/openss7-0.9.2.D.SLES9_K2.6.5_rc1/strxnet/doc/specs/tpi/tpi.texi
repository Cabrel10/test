% -*- texinfo -*- vim: ft=texinfo
% vim: ft=texinfo nosmartindent nocindent noautoindent tw=120
% =========================================================================
%
% @(#) tpi.texi,v 0.9.2.10 2006/01/02 11:59:40 brian Exp
%
% =========================================================================
%
% Copyright (C) 2001-2004  OpenSS7 Corporation <www.openss7.com>
%
% All Rights Reserved.
%
% Permission is granted to make and distribute verbatim copies of this
% manual provided the copyright notice and this permission notice are
% preserved on all copies.
%
% Permission is granted to copy and distribute modified versions of this
% manual under the conditions for verbatim copying, provided that the
% entire resulting derived work is distributed under the terms of a
% permission notice identical to this one
% 
% Since the Linux kernel and libraries are constantly changing, this
% manual page may be incorrect or out-of-date.  The author(s) assume no
% responsibility for errors or omissions, or for damages resulting from
% the use of the information contained herein.  The author(s) may not
% have taken the same level of care in the production of this manual,
% which is licensed free of charge, as they might when working
% professionally.
% 
% Formatted or processed versions of this manual, if unaccompanied by
% the source, must acknowledge the copyright and authors of this work.
%
% -------------------------------------------------------------------------
%
% U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software
% on behalf of the U.S. Government ("Government"), the following
% provisions apply to you.  If the Software is supplied by the Department
% of Defense ("DoD"), it is classified as "Commercial Computer Software"
% under paragraph 252.227-7014 of the DoD Supplement to the Federal
% Acquisition Regulations ("DFARS") (or any successor regulations) and the
% Government is acquiring only the license rights granted herein (the
% license rights customarily provided to non-Government users).  If the
% Software is supplied to any unit or agency of the Government other than
% DoD, it is classified as "Restricted Computer Software" and the
% Government's rights in the Software are defined in paragraph 52.227-19
% of the Federal Acquisition Regulations ("FAR") (or any successor
% regulations) or, in the cases of NASA, in paragraph 18.52.227-86 of the
% NASA Supplement to the FAR (or any successor regulations).
%
% =========================================================================
% 
% Commercial licensing and support of this software is available from
% OpenSS7 Corporation at a fee.  See http://www.openss7.com/
% 
% =========================================================================
%
% Last Modified 2006/01/02 11:59:40 by brian
%
% =========================================================================
\input texinfo @c -*- texinfo -*-
@c vim: ft=texinfo nosmartindent nocindent noautoindent tw=120
@c %**start of header
@setfilename tpi.info
@settitle Transport Provider Interface
@c %**end of header

@dircategory OpenGroup
@direntry
* TPI: (tpi).                   Transport Provider Interface
@end direntry

@include texi/args.texi

@ifinfo
This file documents the X/Open Transport Provider Interface.

This is Edition @value{PACKAGE_VERSION}, last updated @value{PACKAGE_DATE}, for
@value{PACKAGE_TITLE} version @value{PACKAGE_VERSION} release
@value{PACKAGE_RELEASE} published by @uref{http://www.openss7.com/,OpenSS7
Corporation}.

This specification was originally published by UNIX International OSI Special
Interest Group in Revision: 1.5 (1992/12/10).

Copyright @copyright{} 2001-2005  @uref{http://www.openss7.com/, OpenSS7 Corporation} @*
Copyright @copyright{} 1997-2000  @email{bidulock@@openss7.org, Brian F. G. Bidulock} @*
Copyright @copyright{} 1992       UNIX International, Inc.

All Rights Reserved.

Permission is granted to make and distribute verbatim copies of this manual
provided the copyright notice and this permission notice are preserved on all
copies.

@ignore
Permission is granted to process this file through Tex and print the results,
provided the printed document carries copying permission notice identical to
this one except for the removal of this paragraph (this paragraph not being
relevant to the printed manual).

@end ignore
Permission to use, copy, modify, and distribute this documentation for any
purpose and without fee is hereby granted, provided that the above copyright
notice appears in all copies and that both that copyright notice and this
permission notice appear in supporting documentation, and that the name UNIX
International not be used in advertising or publicity pertaining to distribution
of the software without specific, written prior permission. UNIX International
makes no representations about the suitability of this documentation for any
purpose. It is provided ``as is'' without express or implied warranty.

Permission is granted to copy and distribute modified versions of this manual
under the conditions for verbatim copying, provided the entire resulting derived
work is distributed under the terms of a permission notice identical to this
one.

Permission is granted to copy and distribute translations of this manual into
another language, under the above conditions for modified versions.
@end ifinfo

@include texi/args.texi

@shorttitlepage Transport Provider Interface
@titlepage
@title Transport Provider Interface
@subtitle UNIX International
@subtitle OSI Special Interest Group
@subtitle Revision: 1.5
@subtitle December 10, 1992
@sp 0.2
@subtitle Version @value{PACKAGE_VERSION} Edition @value{PACKAGE_RELEASE}
@subtitle Updated @value{PACKAGE_DATE}
@sp 0.2
@subtitle Distributed with Package @value{PACKAGE}-@value{VERSION}
@author Brian Bidulock <@email{bidulock@@openss7.org}> for
@sp 0.2
@author The OpenSS7 Project <@uref{http://www.openss7.org/}>

@page
@vskip 0pt plus 1filll
@subsubheading Published by:

@sp 1

@noindent
@uref{http://www.openss7.com/,OpenSS7 Corporation} @*
1469 Jefferys Crescent @*
Edmonton, Alberta  T6L 6T1 @*
Canada @*

@noindent
Copyright @copyright{} 2001-2004  @uref{http://www.openss7.com/, OpenSS7 Corporation} @*
Copyright @copyright{} 1997-2000  @email{bidulock@@openss7.org, Brian F. G. Bidulock} @*
Copyright @copyright{} 1992       UNIX International, Inc. @*

@noindent
All Rights Reserved. @*

@noindent
Permission is granted to make and distribute verbatim copies of this manual
provided the copyright notice and this permission notice are preserved on all
copies.

@noindent
Permission to use, copy, modify, and distribute this documentation for any
purpose and without fee is hereby granted, provided that the above copyright
notice appears in all copies and that both that copyright notice and this
permission notice appear in supporting documentation, and that the name UNIX
International not be used in advertising or publicity pertaining to distribution
of the software without specific, written prior permission. UNIX International
makes no representations about the suitability of this documentation for any
purpose. It is provided ``as is'' without express or implied warranty.

@noindent
@b{UNIX INTERNATIONAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
DOCUMENTATION, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS,
IN NO EVENT SHALL UNIX INTERNATIONAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR
CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA
OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
DOCUMENTATION.}

@subsubheading Notice:

@noindent
This document is based on the UNIX System Laboratories Transport Provider
Interface (TPI) specification which was used with permission by the UNIX
International OSI Special Interest Group (UI OSISIG).  Participation in the UI
OSISIG is open to UNIX International members and other interested parties.
For further information contact UNIX International at the addresses above.

@noindent
UNIX International is making this documentation available as a reference point
for the industry. While UNIX International believes that these interfaces are
well defined in this release of the document, minor changes may be made prior to
products conforming to the interfaces being made available from UNIX System
Laboratories or UNIX International members.

@subsubheading Trademarks:
UNIX(R) is a registered trademark of UNIX System Laboratories in the United
States and other countries.
X/Open(TM) is a trademark of the X/Open Company Ltd. in the UK and other
countries.
OpenSS7(TM) is a trademark of OpenSS7 Corporation in the United States and other
countries.

@vskip 0pt
@end titlepage
@iftex
@headings off
@everyheading @thistitle @| @thisfile @| @thischaptername
@evenheading @thischapter @| @| @thisfile
@oddheading @thistitle @| @| @thischaptername
@everyfooting Version @value{PACKAGE_VERSION} Rel. @value{PACKAGE_RELEASE} @| @value{PACKAGE_DATE} @| @thispage
@evenfooting @thispage @| @| Version @value{PACKAGE_VERSION} Rel. @value{PACKAGE_RELEASE}
@oddfooting @value{PACKAGE_DATE} @| @| @thispage
@end iftex
@page

@c Define an index of primitives
@defindex pr
@c Define an index of primitive values
@defindex pv
@c Define an index of protocol states
@defindex st

@syncodeindex pr cp
@syncodeindex pv cp
@syncodeindex tp cp
@syncodeindex vr cp

@ifnottex
@node Top
@top Network Provider Interface
@end ifnottex

@menu
* Introduction::
* Transport Provider Interface::
* Mapping of Transport Primitives to OSI::
* Allowable Sequence of Transport Service Primitives::
* Transport Primitive Precedence::
* Index::
@end menu

@node Introduction
@chapter Introduction

To support a framework for providing networking products in the UNIX system, an
effort is underway to define service interfaces that map to strategic levels of
the Open Systems Interconnection (OSI) Reference Model.  These service
interfaces hide implementation details of a particular service from the consumer
of the service.  This enables system programmers to develop software independent
of the particular protocol that provides a specific service.  The interfaces
being specified for UNIX System V are defined within the @dfn{STREAMS}
environment.  This document specifies a kernel-level interface that supports the
services of the Transport Layer for connection-mode and connectionless mode
services.

This specification applies to System V Release 4.2 ES/MP.

@node Transport Provider Interface
@chapter Transport Provider Interface

@menu
* Common Transport Primitives::
* Connection-Mode Transport Primitives::
* Connectionless-Mode Transport Primitives::
* Note about Structure Elements::
* Overview of Error Handling Capabilities::
* Transport Service Interface Sequence of Primitives::
* Precedence of Transport Interface Primitives on a Stream::
* Rules for Flushing Queues::
@end menu

The transport interface defines a message interface to a transport provider
implemented under @dfn{STREAMS}.
@footnote{It is assumed that the reader of this document is familiar with the
concept @dfn{STREAMS}.}

This version of the transport provider interface supports the XPG4 version of
the X/Open Transport Interface (XTI).  A user communicates to a transport
provider via a full duplex path known as a @dfn{stream} (see figure 1). This
@dfn{stream} provides a mechanism in which messages may be passed to the
transport provider from the transport user and vice versa.

@cartouche
@image{tpi_fig1}
@center @b{Figure 1. Example of a stream from a user to a transport provider}
@end cartouche

The @dfn{STREAMS} messages that are used to communicate transport service
primitives between the transport user and the transport provider may have one of
the following formats:

@enumerate

@item
A M_PROTO message block followed by zero or more M_DATA message blocks.  The
M_PROTO message block contains the type of transport service primitive and all
the relevant arguments associated with the primitive. The M_DATA blocks contain
transport user data associated with the transport service primitive.

@item
One M_PCPROTO message block containing the type of transport service primitive
and all the relevant arguments associated with the primitive.

@item
One or more M_DATA message blocks containing transport user data.

@end enumerate

The following sections describe the transport primitives which define both a
connection-mode and connectionless-mode transport service.

For both types of transport service, two types of primitives exist: primitives
which originate from the transport user and primitives which originate from the
transport provider. The primitives which originate from the transport user make
requests to the transport provider or respond to an event of the transport
provider. The primitives which originate from the transport provider are either
confirmations of a request or are indications to the transport user that an
event has occurred.  Section 2 lists the primitive types along with the mapping
of those primitives to the @dfn{STREAMS} message types and the transport
primitives of the ISO IS 8072 and IS 8072/DAD transport service definitions.
The format of these primitives and the rules governing the use of them are
described in sections 2.1, 2.2, and 2.3.

@page
@node Common Transport Primitives
@section Common Transport Primitives

@menu
* MGMT User-Originated Primitives::
* MGMT Provider-Originated Primitives::
* COTS User-Originated Primitives::
* COTS Provider-Originated Primitives::
* CLTS User-Originated Primitives::
* CLTS Provider-Originated Primitives::
@end menu

The following transport primitives are common to both the connection-mode
and connectionless-mode transport services.

@node MGMT User-Originated Primitives
@subsection User-Originated Primitives

@menu
* T_INFO_REQ::
* T_BIND_REQ::
* T_UNBIND_REQ::
* T_OPTMGMT_REQ::
* T_ADDR_REQ::
@end menu

The following describes the format of the transport primitives which are
generated by the transport user.

@node T_INFO_REQ
@subsubsection T_INFO_REQ - get transport protocol parameter sizes.

This primitive requests the transport provider to return the sizes of all
relevant protocol parameters, plus the current state of the provider.
@footnote{The T_INFO_REQ and T_INFO_ACK primitives have no effect on the state
of the transport provider and do not appear in the state tables.}
The format of the message is one M_PCPROTO message block. The format of the
M_PCPROTO message block is as follows:

@smallexample
struct T_info_req @{
        long PRIM_type;                 /* always T_INFO_REQ */
@}
@end smallexample

Where @var{PRIM_type} indicates the primitive type.

This primitive requires the transport provider to generate one of the following
acknowledgements upon receipt of the primitive and that the transport user wait
for the acknowledgement prior to issuing any other primitives:

@itemize --

@item Successful

Acknowledgement of the primitive via the T_INFO_ACK described in
@ref{T_INFO_ACK,,T_INFO_ACK}.

@item Non-fatal errors

There are no errors associated with the issuance of this primitive.

@end itemize

@node T_BIND_REQ
@subsubsection T_BIND_REQ - bind protocol address request.

This primitive requests that the transport provider bind a protocol address to
the stream, negotiate the number of connect indications allowed to be
outstanding by the transport provider for the specified protocol address, and
activate
@footnote{A stream is viewed as active when the transport provider may receive
and transmit TPDUs (transportprotocol data units) associated with
the stream.}
the stream associated with the protocol address. The format of the message is
one M_PROTO message block.  The format of the M_PROTO message block is as
follows:

@smallexample
struct T_bind_req @{
        long PRIM_type;                 /* always T_BIND_REQ */
        long ADDR_length;               /* length of address */
        long ADDR_offset;               /* offset of address */
        unsigned long CONIND_number;    /* requested number of connect
                                           indications to be queued */
@}
@end smallexample

Where @var{PRIM_type} indicates the primitive type.  @var{ADDR_length} is the
length
@footnote{All lengths, offsets, and sizes in all structures refer to the number
of bytes.}
of the protocol address to be bound to the stream and ADDR_offset is the offset
from the beginning of the M_PROTO block where the protocol address begins.
CONIND_number
@footnote{This field should be ignored by those providing a connectionless
transport service.}
is the requested number of connect indications
@footnote{If the number of outstanding connect indications equals CONIND_number,
the transport provider need not discard further incoming connect indications,
but may chose to queue them internally until the number of outstanding connect
indications drops below CONIND_number.}
allowed to be outstanding by the transport provider for the specified protocol
address.  The proper alignment of the address in the M_PROTO message block is
not guaranteed.  The address in the M_PROTO message block is however, aligned
the same as it was received from the transport user.

For rules governing the requests made by this primitive,
@pxref{T_BIND_ACK,,T_BIND_ACK}.

This primitive requires the transport provider to generate one of the following
acknowledgements upon receipt of the primitive, and the transport user must wait
for the acknowledgement before issuing any other primitives:

@itemize --

@item Successful

Correct acknowledgement of the primitive is indicated via the
T_BIND_ACK primitive.

@item Non-fatal errors

These errors will be indicated via the T_ERROR_ACK primitive described in
@ref{T_ERROR_ACK,,T_ERROR_ACK}.
The allowable errors are as follows:

@vtable @var

@item TBADADDR
This indicates that the protocol address was in an incorrect format or the
address contained illegal information. It is not intended to indicate protocol
errors.

@item TNOADDR
This indicates that the transport provider could not allocate an address.

@item TACCES
This indicates that the user did not have proper permissions for the use of the
requested address.

@item TOUTSTATE
The primitive would place the transport interface out of state.

@item TSYSERR
A system error has occurred and the UNIX System error is indicated in the
primitive.

@item TADDRBUSY
This indicates that the requested address is already in use.

@end vtable

@end itemize


@node T_UNBIND_REQ
@subsubsection T_UNBIND_REQ - unbind protocol address request.

This primitive requests that the transport provider unbind the protocol address
associated with the stream and deactivate the @dfn{stream}.
The format of the message is one M_PROTO message block.
The format of the M_PROTO message block is as follows:

@smallexample
struct T_unbind_req @{
        long PRIM_type;                 /* always T_UNBIND_REQ */
@}
@end smallexample

Where @var{PRIM_type} indicates the primitive type.

This primitive requires the transport provider to generate the following
acknowledgements upon receipt of the primitive and that the transport user must
wait for the acknowledgement before issuing any other primitives:

@itemize --

@item Successful

Correct acknowledgement of the primitive is indicated via the T_OK_ACK primitive
described in @ref{T_OK_ACK,,T_OK_ACK}.

@item Non-fatal errors

These errors will be indicated via the T_ERROR_ACK primitive described in
@ref{T_ERROR_ACK,,T_ERROR_ACK}. The allowable errors are as follows:

@vtable @var

@item TOUTSTATE
The primitive would place the transport interface out of state.

@item TSYSERR
A system error has occurred and the UNIX System error is indicated in the
primitive.

@end vtable

@end itemize

@node T_OPTMGMT_REQ
@subsubsection T_OPTMGMT_REQ - options management.

This primitive allows the transport user to manage the options associated with
the stream.
The format of the message is one M_PROTO message block.
The format of the M_PROTO message block is as follows:

@smallexample
struct T_optmgmt_req @{
        long PRIM_type;                 /* always T_OPTMGMT_REQ */
        long OPT_length;                /* options length */
        long OPT_offset;                /* options offset */
        long MGMT_flags;                /* flags */
@}
@end smallexample

Where @var{PRIM_type} indicates the primitive type.
@var{OPT_length} is the length of the protocol options associated with the
primitive and
@var{OPT_offset} is the offset from the beginning of the M_PROTO block where the
options begin.
The proper alignment of the options is not guaranteed.
The options are however, aligned the same as it was received from the transport
user.
@var{MGMT_flags} are the flags which define the request made by the
transport user. The allowable flags are:

@vtable @var
@item T_NEGOTIATE
Negotiate and set the options with the transport provider.
@item T_CHECK
Check the validity of the specified options.
@item T_CURRENT
Return the options currently in effect.
@item T_DEFAULT
Return the default options.
@end vtable

For the rules governing the requests made by this primitive see the
T_OPTMGMT_ACK primitive in @ref{T_OPTMGMT_ACK,,T_OPTMGMT_ACK}.

This primitive requires the transport provider to generate one of the
following acknowledgements upon receipt of the primitive and that the
transport user wait for the acknowledgement before issuing any other
primitives:

@itemize --
@item Successful

Acknowledgement of the primitive via the T_OPTMGMT_ACK.

@item Non-fatal errors

These errors will be indicated via the T_ERROR_ACK primitive described in
@ref{T_ERROR_ACK,,T_ERROR_ACK}. The allowable errors are as follows:

@vtable @var

@item TACCES
This indicates that the user did not have proper permissions for the use of the
requested options.

@item TOUTSTATE
The primitive would place the transport interface out of state.

@item TBADOPT
This indicates that the options as specified were in an incorrect format, or
they contained illegal information.

@item TBADFLAG
This indicates that the flags as specified were incorrect or illegal.

@item TSYSERR
A system error has occurred and the UNIX System error is indicated in the
primitive.

@item TNOTSUPPORT
This transport provider does not support the requested flag (T_CHECK or
T_CURRENT).

@end vtable

@end itemize

@node T_ADDR_REQ
@subsubsection T_ADDR_REQ - get protocol addresses request.

This primitive requests that the transport provider return the local protocol
address that is bound to the stream and the address of the remote transport
entity if a connection has been established.

The format of the message is one M_PROTO message block. The format of the
M_PROTO message block is as follows:

@smallexample
struct T_addr_req @{
        long PRIM_type;                 /* always T_ADDR_REQ */
@}
@end smallexample

Where @var{PRIM_type} indicates the primitive type. This primitive requires the
transport provider to generate one of the following acknowledgements upon
receipt of the primitive, and the transport user must wait for the
acknowledgement before issuing any other primitives:

@itemize --

@item Successful

Correct acknowledgement of the primitive is indicated via the T_ADDR_ACK
primitive.

@item Non-fatal errors

There are no errors associated with the issuance of this primitive.

@end itemize

@node MGMT Provider-Originated Primitives
@subsection Provider-Originated Primitives

@menu
* T_INFO_ACK::
* T_BIND_ACK::
* T_OPTMGMT_ACK::
* T_ERROR_ACK::
* T_OK_ACK::
* T_ADDR_ACK::
@end menu

The following describes the format of the transport primitives which are
generated by the transport provider.

@node T_INFO_ACK
@subsubsection T_INFO_ACK - protocol information acknowledgement.

This primitive indicates to the transport user any relevant protocol-dependent
parameters.  It should be initiated in response to the T_INFO_REQ primitive
described above.
The format of this message is one M_PCPROTO message block.
The format of the M_PCPROTO message block is as follows:

@smallexample
struct T_info_ack @{
        long PRIM_type;                 /* always T_INFO_ACK */
        long TSDU_size;                 /* max TSDU size */
        long ETSDU_size;                /* max ETSDU size */
        long CDATA_size;                /* Connect data size */
        long DDATA_size;                /* Discon data size */
        long ADDR_size;                 /* TSAP size */
        long OPT_size;                  /* options size */
        long TIDU_size;                 /* TIDU size */
        long SERV_type;                 /* service type */
        long CURRENT_state;             /* current state */
        long PROVIDER_flag;             /* provider flags */
@}
@end smallexample

where the fields of this message have the following meanings:

@vtable @var

@item PRIM_type
This indicates the primitive type.

@item TSDU_size
A value greater than zero specifies the maximum size of a transport service data
unit (TSDU); a value of zero specifies that the transport provider does not
support the concept of TSDU, although it does support the sending of a data
stream with no logical boundaries preserved across a connection; a value of -1
specifies that there is nolimit on the size of a TSDU; and a value of -2
specifies that the transfer of normal data is not supported by the transport
provider.

@item ETSDU_size
A value greater than zero specifies the maximum size of an expeditedtransport
service data unit (ETSDU); a value of zero specifies that the transport provider
does not support the concept of ETSDU, although it does support the sending of
an expedited data stream with no logical boundaries preserved across a
connection; a value of -1 specifies thatthere is no limit on the size of an
ETSDU; and a value of -2 specifies that the transfer of expedited data is not
supported by the transport provider.

@item CDATA_size
A value greater than or equal to zero specifies the maximum amount of data that
may be associated with connection establishment primitives; and a value of -2
specifies that the transport provider does not allow data to be sent with
connection establishment primitives.

@item DDATA_size
A value greater than or equal to zero specifies the maximum amount of data that
may be associated with the disconnect primitives; and a value of -2 specifies
that the transport provider does not allow data to be sent with the disconnect
primitives.

@item ADDR_size
A value greater than or equal to zero indicates the maximum size of a transport
protocol address; and a value of -2 specifies that the transport provider does
not provide user access to transport protocol addresses.

@item OPT_size
A value greater than or equal to zero indicates the maximum number of bytes of
protocol-specific options supported by the provider; a value of -2 specifies
that the transport provider does not support user-settable options although
they're read-only; and a value of -3 specifies that the transport provider does
not support any options.

@item TIDU_size
@footnote{This is the amount of user data that may be present in a single
T_DATA_REQ or T_EXDATA_REQ primitive.} This is the size of the transport
protocol interface data unit, and should not exceed the tunable system limit, if
non-zero, for the size of a STREAMS message.

@item SERV_type
This field specifies the service type supported by the transport provider, and
is one of the following:

@vtable @var

@item T_COTS
The provider service is connection oriented with no orderly release support.

@item T_COTS_ORD
The provider service is connection oriented with orderly release support.

@item T_CLTS
The provider service is a connectionless transport service.

@end vtable

@item CURRENT_state
This is the current state of the transport provider.

@item PROVIDER_flag
This field specifies additional properties specific to the transport provider
and may alter the way the transport user communicates.  Transport providers
supporting the features of XTI in XPG4 and beyond must send up a version number
as specified below. The following flags may be set by the provider:

@vtable @var

@item SENDZERO
This flag indicates that the transport provider supports the sending of
zero-length TSDUs.

@item XPG4_1
This indicates that the transport provider conforms to XTI in XPG4 and supports
the new primitives T_ADDR_REQ and T_ADDR_ACK.

@end vtable

@end vtable

The following rules apply when the type of service is T_CLTS:

@itemize ---
@item The ETSDU_size, CDATA_size and DDATA_size fields should be -2.
@item The TSDU_size should equal the TIDU_size.
@end itemize

@node T_BIND_ACK
@subsubsection T_BIND_ACK - bind protocol address acknowledgement.

This primitive indicates to the transport user that the specified protocol
address has been bound to the stream, that the specified number of connect
indications are allowed to be queued by the transport provider for the specified
protocol address, and that the stream associated with the specified protocol
address has been activated. The format of the message is one M_PCPROTO message
block. The format of the M_PCPROTO message block is as follows:

@smallexample
struct T_bind_ack @{
        long PRIM_type;                 /* always T_BIND_ACK */
        long ADDR_length;               /* length of address - see note in sec. 1.4 */
        long ADDR_offset;               /* offset of address */
        unsigned long CONIND_number;    /* connect indications to be queued */
@}
@end smallexample

Where @var{PRIM_type} indicates the primitive type.  @var{ADDR_length} is the
length of the protocol address that was bound to the stream and
@var{ADDR_offset} is the offset from the beginning of the M_PCPROTO block where
the protocol address begins. @var{CONIND_number}@footnote{This field doesn't
apply to connectionless transport providers.} is the accepted number of connect
indications allowed to be outstanding by the transport provider for the
specified protocol address. The proper alignment of the address in the M_PCPROTO
message block is not guaranteed.

The following rules apply to the binding of the specified protocol address to
the stream:

@itemize ---

@item If the ADDR_length field in the T_BIND_REQ primitive is 0, then the transport
provider must assign a transport protocol address to the user.

@item The transport provider is to bind the transport protocol address as specified
in the T_BIND_REQ primitive. If the requested transport protocol address is in
use or if the transport provider cannot bind the specified address, it must
return an error.

@end itemize

The following rules apply to negotiating the CONIND_number argument:

@itemize ---

@item The returned value must be less than or equal to the corresponding requested
number as indicated in the T_BIND_REQ primitive.

@item If the requested value is greater than zero, the returned value must also be
greater than zero.

@item Only one stream that is bound to the indicated protocol address may have a
negotiated accepted number of maximum connect requests greater than zero. If a
T_BIND_REQ primitive specifies a value greater than zero, but another stream has
already bound itself to the given protocol address with a value greater than
zero, the transport provider must return an error.

@item If a stream with CONIND_number greater than zero is used to accept a
connection, the stream will be found busy during the duration of that connection
and no other streams may be bound to that protocol address with a CONIND_number
greater than zero. This will prevent more than one stream bound to the identical
protocol address from accepting connect indications.

@item A stream requesting a CONIND_number of zero should always be legal. This
indicates to the transport provider that the stream is to be used to request
connections only.

@item A stream with a negotiated CONIND_number greater than zero may generate
connect requests or accept connect indications.

@end itemize

If the above rules result in an error condition, then the transport provider
must issue an T_ERROR_ACK primitive to the transport user specifying the error
as defined in the description of the T_BIND_REQ primitive.

@node T_OPTMGMT_ACK
@subsubsection T_OPTMGMT_ACK - option management acknowledgement.

This indicates to the transport user that the options management request has
completed.  The format of the message is one M_PCPROTO message block. The format
of the M_PCPROTO message block is as follows:

@smallexample
struct T_optmgmt_ack @{
        long PRIM_type;                 /* always T_OPTMGMT_ACK */
        long OPT_length;                /* options length - see note in sec. 1.4 */
        long OPT_offset;                /* options offset */
        long MGMT_flags;                /* flags */
@}
@end smallexample

Where @var{PRIM_type} indicates the primitive type.  @var{OPT_length} is the
length of the protocol options associated with the primitive and
@var{OPT_offset} is the offset from the beginning of the M_PCPROTO block where
the options begin. The proper alignment of the options is not guaranteed.

@var{MGMT_flags} should be the same as those specified in the T_OPTMGMT_REQ
primitive with any additional flags as specified below.

The following rules apply to the T_OPTMGMT_ACK primitive.

@itemize ---

@item If the value of MGMT_flags in the T_OPTMGMT_REQ primitive is T_DEFAULT,
the provider should return the default provider options without changing the
existing options associated with the stream.

@item If the value of MGMT_flags in the T_OPTMGMT_REQ primitive is T_CHECK, the
provider should return the options as specified in the T_OPTMGMT_REQ primitive
along with the additional flags T_SUCCESS or T_FAILURE which indicate to the
user whether the specified options are supportable by the provider. The provider
should not change any existing options associated with the stream.

@item If the value of MGMT_flags in the T_OPTMGMT_REQ primitive is
T_NEGOTIATE, the provider should set and negotiate the option as specified by
the following rules:

@itemize ---

@item If the OPT_length field of the T_OPTMGMT_REQ primitive is 0, then the
transport provider is to set and return the default options associated
with the stream in the T_OPTMGMT_ACK primitive.

@item If options are specified in the T_OPTMGMT_REQ primitive, then the transport
provider should negotiate those options, set the negotiated options and return
the negotiated options in the T_OPTMGMT_ACK primitive. It is the user's
responsibility to check the negotiated options returned in the T_OPTMGMT_ACK
primitive and take appropriate action.

@end itemize

@item If the value of MGMT_flags in the T_OPTMGMT_REQ primitive is T_CURRENT,
the provider should return the current options that are currently
associated with the stream.

@item If the value of MGMT_flags in the T_OPTMGMT_REQ primitive is either
T_NEGOTIATE or T_CHECK and the transport provider cannot support the requested
flag, an error is to be returned.

@end itemize

If the above rules result in an error condition, the transport provider must
issue a T_ERROR_ACK primitive to the transport user specifying the error as
defined in the description of the T_OPTMGMT_REQ primitive.

@node T_ERROR_ACK
@subsubsection T_ERROR_ACK - error acknowledgement.

This primitive indicates to the transport user that a non-fatal@footnote{For a
overview of the error handling capabilities available to the transport provider
see section 2.4.} error has occurred in the last transport-user-originated
primitive. This may only be initiated as an acknowledgement for those primitives
that require one. It also indicates to the user that no action was taken on the
primitive that caused the error. The format of the message is one M_PCPROTO
message block. The format of the M_PCPROTO message block is as follows:

@smallexample
struct T_error_ack @{
        long PRIM_type;                 /* always T_ERROR_ACK */
        long ERROR_prim;                /* primitive in error */
        long TLI_error;                 /* TLI error code - see note in sec. 1.4 */
        long UNIX_error;                /* UNIX error code - see note in sec. 1.4 */
@}
@end smallexample

Where @var{PRIM_type} identifies the primitive.  @var{ERROR_prim} identifies the
primitive type that caused the error and @var{TLI_error} contains the Transport
Level Interface error code.  @var{UNIX_error} contains the UNIX System error
code. This may only be non zero if TLI_error is equal to TSYSERR.  The following
Transport Level Interface error codes are allowed to be returned:

@vtable @var

@item TBADADDR
This indicates that the protocol address as specified in the primitive was in an
incorrect format or the address contained illegal information.

@item TBADOPT
This indicates that the options as specified in the primitive were in an
incorrect format, or they contained illegal information.

@item TBADF
This indicates that the stream queue pointer as specified in the primitive was
illegal.

@item TNOADDR 
This indicates that the transport provider could not allocate an address.

@item TACCES
This indicates that the user did not have proper permissions.

@item TOUTSTATE
The primitive would place the interface out of state.

@item TBADSEQ
The sequence number specified in the primitive was incorrect or illegal.

@item TBADFLAG
The flags specified in the primitive were incorrect or illegal.

@item TBADDATA
The amount of user data specified was illegal.

@item TSYSERR
A system error has occurred and the UNIX System error is indicated in the
primitive.

@item TADDRBUSY
The requested address is in use.

@item TRESADDR
The transport provider requires that the responding stream is bound to the same
address as the stream on which the connection indication was received.

@item TNOTSUPPORT
The transport provider does not support the requested capability.

@end vtable

@node T_OK_ACK
@subsubsection T_OK_ACK - success acknowledgement.

This primitive indicates to the transport user that the previous
transport-user-originated primitive was received successfully by the transport
provider. It does not indicate to the transport user any transport protocol
action taken due to the issuance of the last primitive.  This may only be
initiated as an acknowledgement for those primitives that require one. The
format of the message is one M_PCPROTO message block. The format of the
M_PCPROTO message block is as follows:

@smallexample
struct T_ok_ack @{
        long PRIM_type;                 /* always T_OK_ACK */
        long CORRECT_prim;              /* primitive */
@}
@end smallexample

Where @var{PRIM_type} identifies the primitive.  @var{CORRECT_prim} contains the
successfully received primitive type.

@node T_ADDR_ACK
@subsubsection T_ADDR_ACK - get protocol addresses acknowledgement.

This primitive indicates to the transport user the addresses of the local and
remote transport entities. The local address is the protocol address that has
been bound to the stream. If a connection has been established, the remote
address is the protocol address of the remote transport entity. The format of
the message is one M_PCPROTO message block. The format of the M_PCPROTO message
block is as follows:

@smallexample
struct T_addr_ack @{
        long PRIM_type;                 /* always T_ADDR_ACK */
        long LOCADDR_length;            /* length of local address - see note
                                           in sec. 1.4 */
        long LOCADDR_offset;            /* offset of local address */
        long REMADDR_length;            /* length of remote address - see note
                                           in sec. 1.4 */
        long REMADDR_offset;            /* offset of remote address */
@}
@end smallexample

Where @var{PRIM_type} indicates the primitive type.  @var{LOCADDR_length} is the
length of the protocol address that was bound to the stream and
@var{LOCADDR_offset} is the offset from the beginning of the M_PCPROTO block
where the protocol address begins. If the stream is in the data transfer state,
@var{REMADDR_length} is the length of the protocol address of the remote
transport entity and @var{REMADDR_offset} is the offset from the beginning of
the M_PCPROTO block where the protocol address begins.

The following rules apply:

@itemize ---

@item If the interface is in any state but T_DATAXFER, the values returned for
REMADDR_length and REMADDR_offset must be 0.

@item If the interface is in the T_UNINIT or T_UNBND state, the values returned
for LOCADDR_length and LOCADDR_offset must be 0.

@end itemize

@page
@node Connection-Mode Transport Primitives
@section Connection-Mode Transport Primitives

The following transport primitives pertain only to the connection-mode transport
service.

@node COTS User-Originated Primitives
@subsection User-Originated Primitives

@menu
* T_CONN_REQ::
* T_CONN_RES::
* T_DISCON_REQ::
* T_DATA_REQ::
* T_EXDATA_REQ::
* T_ORDREL_REQ::
@end menu

The following describes the format of the transport primitives which are
generated by the transport user.

@node T_CONN_REQ
@subsubsection T_CONN_REQ - connect request.

This primitive requests that the transport provider make a connection to the
specified destination. The format of this message is one M_PROTO message block
followed by zero or more M_DATA blocks if any user data is specified by the
transport user. The format of the M_PROTO message block is as follows:

@smallexample
struct T_conn_req @{
        long PRIM_type;                 /* always T_CONN_REQ */
        long DEST_length;               /* dest addr length */
        long DEST_offset;               /* dest addr offset */
        long OPT_length;                /* options length */
        long OPT_offset;                /* options offset */
@}
@end smallexample

Where @var{PRIM_type} identifies the primitive type.  @var{DEST_length} is the
length of the destination address and @var{DEST_offset} is the offset from the
beginning of the M_PROTO message block where the destination address begins.
Similarly, @var{OPT_length} and @var{OPT_offset} describe the location of the
requested options associated with the primitive.  The proper alignment of the
destination address and options in the M_PROTO message block is not
guaranteed.@footnote{The information located by the defined structures may not
be in the proper alignment in the message blocks, so the casting of structure
definitions over these fields may produce incorrect results. It is advised that
the transport providers supply exact format specifications for the appropriate
information to the transport users.} The destination address and options in the
M_PROTO message block are however, aligned the same as they were received from
the transport user.

This primitive requires the transport provider to generate one of the following
acknowledgements upon receipt of the primitive, and the transport user must wait
for the acknowledgement before issuing any other primitives:

@itemize --

@item Successful

Correct acknowledgement of the primitive is indicated via the T_OK_ACK primitive
described in @ref{T_OK_ACK,,T_OK_ACK}.

@item Non-fatal errors

These errors will be indicated via the T_ERROR_ACK primitive described in
@ref{T_ERROR_ACK,,T_ERROR_ACK}. The allowable errors are as follows:

@vtable @var

@item TACCES
This indicates that the user did not have proper permissions for the use of the
requested address or options.

@item TBADADDR
This indicates that the protocol address was in an incorrect format or the
address contained illegal information. It is not intended to indicate protocol
connection errors, such as an unreachable destination. Those error types are
indicated via the T_DISCON_IND primitive.

@item TBADOPT
This indicates that the options were in an incorrect format, or they contained
illegal information.

@item TOUTSTATE
The primitive would place the transport interface out of state.

@item TBADDATA
The amount of user data specified was illegal.

@item TSYSERR
A system error has occurred and the UNIX System error is indicated in the
primitive.

@item TADDRBUSY
This transport provider does not support multiple connections with the same
local and remote addresses.

@end vtable

@end itemize

@node T_CONN_RES
@subsubsection T_CONN_RES - connection response.

This primitive requests that the transport provider accept a previous connect
request on the specified response queue.  The format of this message is one
M_PROTO message block followed by zero or more M_DATA blocks if any user data is
specified by the transport user. The format of the M_PROTO message block is as
follows:

@smallexample
struct T_conn_res @{
        long PRIM_type;                 /* always T_CONN_RES */
        queue_t *QUEUE_ptr;             /* response queue ptr */
        long OPT_length;                /* options length */
        long OPT_offset;                /* options offset */
        long SEQ_number;                /* sequence number */
@}
@end smallexample

Where @var{PRIM_type} identifies the primitive type.  @var{QUEUE_ptr} identifies
the transport provider queue pair (i.e.  read queue pointer) which should be
used to accept the connect request. This queue pointer should map onto a stream
which is already bound to a protocol address but if the stream is not bound, the
transport provider must bind it to the same protocol address that was bound to
the stream on which the connection indication arrived.  @var{OPT_length} is the
length of the responding options and @var{OPT_offset} is the offset from the
beginning of the M_PROTO message block where the responding options begin.
@var{SEQ_number} is the sequence number which identifies the connection to be
responded to.  The proper alignment of the options in the M_PROTO message block
is not guaranteed.  The options in the M_PROTO message block are, however,
aligned the same as they were received from the transport user.

This primitive requires the transport provider to generate one of the following
acknowledgements upon receipt of the primitive, and the transport user wait for
the acknowledgement before issuing any other primitives:

@itemize --

@item Successful

Correct acknowledgement of the primitive is indicated via the T_OK_ACK primitive
described in @ref{T_OK_ACK,,T_OK_ACK}.

@item Non-fatal errors

These errors will be indicated via the T_ERROR_ACK primitive described in
@ref{T_ERROR_ACK,,T_ERROR_ACK}. The allowable errors are as follows:

@vtable @var

@item TBADF
This indicates that the response queue pointer was illegal.

@item TBADOPT
This indicates that the options were in an incorrect format, or they contained
illegal information.

@item TACCES
This indicates that the user did not have proper permissions for the use of the
options or response id.

@item TOUTSTATE
The primitive would place the transport interface out of state.

@item TBADDATA
The amount of user data specified was illegal.

@item TBADSEQ
The sequence number specified in the primitive was incorrect or illegal.

@item TSYSERR
A system error has occurred and the UNIX System error is indicated in the
primitive.

@item TRESADDR
The transport provider requires that the responding stream is bound to the same
address as the stream on which the connection indication was received.

@item TBADADDR
This indicates that the protocol address was in an incorrect format or the
address contained illegal information.

@end vtable

@end itemize

@node T_DISCON_REQ
@subsubsection T_DISCON_REQ - disconnect request.

This primitive requests that the transport provider deny a request for
connection, or disconnect an existing connection. The format of this message is
one M_PROTO message block possibly followed by one or more M_DATA message blocks
if there is any user data specified by the transport user. The format of the
M_PROTO message block is as follows:

@smallexample
struct T_discon_req @{
        long PRIM_type;                 /* always T_DISCON_REQ */
        long SEQ_number;                /* sequence number */
@}
@end smallexample

Where @var{PRIM_type} identifies the primitive type.  @var{SEQ_number}
identifies the outstanding connect indication that is to by denied. If the
disconnect request is disconnecting an already existing connection, then the
value of @var{SEQ_number} will be ignored.

This primitive requires the transport provider to generate the following
acknowledgement upon receipt of the primitive, and the transport user must wait
for the acknowledgement prior to issuing any other primitives:

@itemize --

@item Successful

Correct acknowledgement of the primitive is indicated via the T_OK_ACK primitive
described in @ref{T_OK_ACK,,T_OK_ACK}.

@item Non-fatal errors

These errors will be indicated via the T_ERROR_ACK primitive described in
@ref{T_ERROR_ACK,,T_ERROR_ACK}. The allowable errors are as follows:

@vtable @var

@item TOUTSTATE
The primitive would place the transport interface out of state.

@item TBADDATA
The amount of user data specified was illegal.

@item TBADSEQ
The sequence number specified in the primitive was incorrect or illegal.

@item TSYSERR
A system error has occurred and the UNIX System error is indicated in the
primitive.

@end vtable

@end itemize

@node T_DATA_REQ
@subsubsection T_DATA_REQ - data request.

This primitive indicates to the transport provider that this message contains a
transport interface data unit. One or more transport interface data units form a
transport service data unit (TSDU).@footnote{The maximum transport service data
unit size allowed by the transport provider is indicated to the transport user
via the T_INFO_ACK primitive.} This primitive has a mechanism that indicates the
beginning and end of a transport service data unit. However, not all transport
providers support the concept of a transport service data unit, as noted in
@ref{T_INFO_ACK,,T_INFO_ACK}. The format of the message is one M_PROTO message
block followed by zero or more M_DATA message blocks where each

M_DATA message block contains zero or more bytes of data. The format of the
M_PROTO message block is as follows:

@smallexample
struct T_data_req @{
        long PRIM_type;                 /* always T_DATA_REQ */
        long MORE_flag;                 /* indicates more data in TSDU */
@}
@end smallexample

Where @var{PRIM_type} identifies the primitive type.  @var{MORE_flag} when
greater than zero, indicates that the next T_DATA_REQ primitive is also part of
this transport service data unit.

The transport provider must also recognize a message of one or more M_DATA
message blocks without the leading M_PROTO message block as a T_DATA_REQ
primitive. This message type will be initiated from the WRITE(BA_OS) operating
system service routine.  In this case there are no implied transport service
data unit boundaries, and the transport provider may view this message type as a
self contained transport service data unit. If these two types of messages are
intermixed, then transport service data boundaries may be lost.

This primitive does not require any acknowledgements, although it may generate a
fatal error.  This is indicated via a M_ERROR message type which results in the
failure of all operating system service routines on the stream. The allowable
errors are as follows:

@vtable @var

@item EPROTO

This indicates one of the following unrecoverable protocol conditions:

@itemize ---

@item The transport service interface was found to be in an incorrect state. If
the interface is in the T_IDLE state when the provider receives the T_DATA_REQ
primitive, then the transport provider should just drop the message without
generating a fatal error.

@item The amount of transport user data associated with the primitive defines a
transport service data unit larger than that allowed by the transport provider.

@end itemize

@end vtable

@node T_EXDATA_REQ
@subsubsection T_EXDATA_REQ - expedited data request.

This primitive indicates to the transport provider that this message contains an
expedited transport interface data unit. One or more expedited transport
interface data units form an expedited transport service data unit.@footnote{The
maximum size of a expedited transport service data unit is indicated to the
transport user via theT_INFO_ACK primitive.} This primitive has a mechanism
which indicates the beginning and end of an expedited transport service data
unit. However, not all transport providers support the concept of an expedited
transport service data unit, as noted in @ref{T_INFO_ACK,,T_INFO_ACK}. The format
of the message is one M_PROTO message block followed by one or more M_DATA
message blocks containing at least one byte of data.  The format of the M_PROTO
message block is as follows:

@smallexample
struct T_exdata_req @{
        long PRIM_type;                 /* always T_EXDATA_REQ */
        long MORE_flag;                 /* indicates more data in ETSDU */
@}
@end smallexample

Where PRIM_type identifies the primitive type. MORE_flag when greater than zero
indicates that the next T_EXDATA_REQ primitive is also part of this expedited
transport service data unit.

This primitive does not require any acknowledgements, although it may generate a
fatal error. This is indicated via a M_ERROR message type which results in the
failure of all operating system service routines on the stream. The allowable
errors are as follows:

@vtable @var

@item EPROTO
This indicates one of the following unrecoverable protocol conditions:

@itemize ---

@item The transport service interface was found to be in an incorrect state. If
the interface is in the T_IDLE state when the provider receives the T_EXDATA_REQ
primitive, then the transport provider should just drop the message without
generating a fatal error.

@item The amount of transport user data associated with the primitive defines an
expedited transport service data unit larger than that allowed by the transport
provider.

@end itemize

@end vtable

@node T_ORDREL_REQ
@subsubsection T_ORDREL_REQ - orderly release request.

This primitive indicates to the transport provider that the user is finished
sending data.  This primitive is only supported by the transport provider if it
is of type T_COTS_ORD.  The format of the message is one M_PROTO message block.
The format of the M_PROTO message block is as follows:

@smallexample
struct T_ordrel_req @{
        long PRIM_type;                 /* always T_ORDREL_REQ */
@}
@end smallexample

Where @var{PRIM_type} identifies the primitive type.

This primitive does not require any acknowledgements, although it may generate a
fatal error. This is indicated via a M_ERROR message type which results in the
failure of all operating system service routines on the stream. The allowable
errors are as follows:

@vtable @var

@item EPROTO
This indicates one of the following unrecoverable protocol conditions:

@itemize ---

@item The primitive would place the interface in an incorrect state.

@end itemize

@end vtable

@node COTS Provider-Originated Primitives
@subsection Provider-Originated Primitives

@menu
* T_CONN_IND::
* T_CONN_CON::
* T_DISCON_IND::
* T_DATA_IND::
* T_EXDATA_IND::
* T_ORDREL_IND::
@end menu

The following describes the format of the transport primitives which are
generated by the transport provider.

@node T_CONN_IND
@subsubsection T_CONN_IND - connect indication.

This primitive indicates to the transport user that a connect request to the
user has been made by the user at the specified source address. The format of
this message is one M_PROTO message block followed by zero or more M_DATA blocks
if any user data is associated with the primitive. The format of the M_PROTO
message block is as follows:

@smallexample
struct T_conn_ind @{
        long PRIM_type;                 /* always T_CONN_IND */
        long SRC_length;                /* source addr length - see note in
                                           sec. 1.4 */
        long SRC_offset;                /* source addr offset */
        long OPT_length;                /* options length - see note in sec.
                                           1.4 */
        long OPT_offset;                /* options offset */
        long SEQ_number;                /* sequence number - see note in sec.
                                           1.4 */
@}
@end smallexample

Where @var{PRIM_type} identifies the primitive type.  @var{SRC_length} is the
length of the source address and SRC_offset is the offset from the beginning of
the M_PROTO message block where the source address begins. Similarly,
@var{OPT_length} and @var{OPT_offset} describe the location of the requested
options associated with the primitive.  @var{SEQ_number} should bean unique
number other than -1 to identify the connect indication. The proper alignment of
the source address and options in the M_PROTO message block is not guaranteed.

@node T_CONN_CON
@subsubsection T_CONN_CON - connection confirm.

This primitive indicates to the user that a connect request has been confirmed
on the specified responding address. The format of this message is one M_PROTO
message block followed by zero or more M_DATA blocks if any user data is
associated with the primitive. The format of the M_PROTO message block is as
follows:

@smallexample
struct T_conn_con @{
        long PRIM_type;                 /* always T_CONN_CON */
        long RES_length;                /* responding addr length - see note in 
                                           sec. 1.4 */
        long RES_offest;                /* responding addr offset */
        long OPT_length;                /* options length - see note in sec.
                                           1.4 */
        long OPT_offset;                /* options offset */
@}
@end smallexample

Where @var{PRIM_type} identifies the primitive type.  @var{RES_length} is the
length of the responding address that the connection was accepted on and
@var{RES_offset} is the offset from the beginning of the M_PROTO message block
where the responding address begins.  Similarly, @var{OPT_length} and
@var{OPT_offset} describe the size and location of the confirmed options
associated with the primitive.  The proper alignment of the responding address
and options in the M_PROTO message block is not guaranteed.

@node T_DISCON_IND
@subsubsection T_DISCON_IND - disconnect indication.

This primitive indicates to the user that either a request for connection has
been denied or an existing connection has been disconnected. The format of this
message is one M_PROTO message block possibly followed by one or more M_DATA
message blocks if there is any user data associated with the primitive. The
format of the M_PROTO message block is as follows:

@smallexample
struct T_discon_ind @{
        long PRIM_type;                 /* always T_DISCON_IND */
        long DISCON_reason;             /* disconnect reason - see note in sec. 
                                           1.4 */
        long SEQ_number;                /* sequence number - see note in sec.
                                           1.4 */
@}
@end smallexample

Where @var{PRIM_type} identifies the primitive type and @var{DISCON_reason} is
the reason for disconnect.  The reason codes are protocol specific.
@var{SEQ_number} is the sequence number which identifies which connect
indication was denied, or it is -1 if the provider is disconnecting an existing
connection.  The @var{SEQ_number} is only meaningful when this primitive is sent
to a passive user who has the corresponding connect indication outstanding. It
allows the transport user to identify which of its outstanding connect
indications is associated with the disconnect.

@node T_DATA_IND
@subsubsection T_DATA_IND - data indication.

This primitive indicates to the transport user that this message contains a
transport interface data unit. One or more transport interface data units form a
transport service data unit. This primitive has a mechanism which indicates the
beginning and end of a transport service data unit. However, not all transport
providers support the concept of a transport service data unit, as noted in
@ref{T_INFO_ACK,,T_INFO_ACK}. The format of the message is one M_PROTO message
block followed by zero or more M_DATA message blocks where each M_DATA message
block, except for the last, must contain at least one byte of data.  The format
of the M_PROTO message block is as follows:

@smallexample
struct T_data_ind @{
        long PRIM_type;                 /* always T_DATA_IND */
        long MORE_flag;                 /* indicates more data in TSDU */
@}
@end smallexample

Where @var{PRIM_type} identifies the primitive type.  @var{MORE_flag}, when
greater than zero, indicates that the next T_DATA_IND primitive is also part of
this transport service data unit.  If a TSDU spans multiple T_DATA_IND message
blocks, then an ETSDU may be placed in between two T_DATA_IND message blocks.
Once an ESTDU is started, then the ETSDU must be completed before any T_DATA_IND
message blocks defining a TSDUis resumed.

@node T_EXDATA_IND
@subsubsection T_EXDATA_IND - expedited data indication.

This primitive indicates to the transport user that this message contains an
expedited transport interface data unit. One or more expedited transport
interface data units form an expedited transport service data unit. This
primitive has a mechanism which indicates the beginning and end of an expedited
transport service data unit. However, not all transport providers support the
concept of an expedited transport service data unit, as noted in
@ref{T_INFO_ACK,,T_INFO_ACK}. The format of the message is one M_PROTO message
block followed by one or more M_DATA message blocks containing at least one byte
of data.  The format of the M_PROTO message block is as follows:

@smallexample
struct T_exdata_ind @{
        long PRIM_type;                 /* always T_EXDATA_IND */
        long MORE_flag;                 /* indicates more data in ETSDU */
@}
@end smallexample

Where @var{PRIM_type} identifies the primitive type.  @var{MORE_flag}, when
greater than zero, indicates that the next T_EXDATA_IND primitive is also part of
this expedited transport service data unit.

@node T_ORDREL_IND
@subsubsection T_ORDREL_IND - orderly release indication.

This primitive indicates to the transport user that the user on the other side
of the connection is finished sending data. This primitive is only supported by
the transport provider if it is of type T_COTS_ORD. The format of the message is
one M_PROTO message block. The format of the M_PROTO message block is as
follows:

@smallexample
struct T_ordrel_ind @{
        long PRIM_type;                 /* always T_ORDREL_IND */
@}
@end smallexample

Where @var{PRIM_type} identifies the primitive type.

@page
@node Connectionless-Mode Transport Primitives
@section Connectionless-Mode Transport Primitives

The following transport primitives pertain only to the connectionless-mode
transport service.

@node CLTS User-Originated Primitives
@subsection User-Originated Primitives

@menu
* T_UNITDATA_REQ::
@end menu

@node T_UNITDATA_REQ
@subsubsection T_UNITDATA_REQ - unitdata request.

This primitive requests that the transport provider send the specified datagram
to the specified destination. The format of the message is one M_PROTO message
block followed by zero or more M_DATA message blocks where each M_DATA message
block contains zero or more bytes of data. The format of the M_PROTO message
block is as follows:

@smallexample
struct T_unitdata_req @{
        long PRIM_type;                 /* always T_UNITDATA_REQ */
        long DEST_length;               /* dest addr length */
        long DEST_offset;               /* dest addr offset */
        long OPT_length;                /* options length */
        long OPT_offset;                /* options offset */
@}
@end smallexample

Where @var{PRIM_type} identifies the primitive type.  @var{DEST_length} is the
length of the destination address and @var{DEST_offset} is the offset from the
beginning of the M_PROTO message block where the destination address begins.
Similarly, @var{OPT_length} and @var{OPT_offset} describe the location of the
requested options associated with the primitive.  The proper alignment of the
destination address and options in the M_PROTO message block is not guaranteed.
The destination address and options in the M_PROTO message block are, however,
aligned the same as they were received from the transport user.

This primitive does not require any acknowledgement. If an non-fatal error
occurs, it is the responsibility of the transport provider to report it via the
T_UDERROR_IND indication. Fatal errors are indicated via a M_ERROR message type
which results in the failure of all operating system service routines on the
stream. The allowable fatal errors are as follows:

@vtable @var

@item EPROTO
This indicates one of the following unrecoverable protocol conditions:

@itemize ---

@item The transport service interface was found to be in an incorrect state.

@item The amount of transport user data associated with the primitive defines an
transport service data unit larger than that allowed by the transport provider.

@end itemize

@end vtable

@node CLTS Provider-Originated Primitives
@subsection Provider-Originated Primitives

@menu
* T_UNITDATA_IND::
* T_UDERROR_IND::
@end menu

@node T_UNITDATA_IND
@subsubsection T_UNITDATA_IND - unitdata indication.

This primitive indicates to the transport user that a datagram has been received
from the specified source address. The format of the message is one M_PROTO
message block followed by zero or more M_DATA message blocks where each M_DATA
message block contains at least one byte of data. The format of the M_PROTO
message block is as follows:

@smallexample
struct T_unitdata_ind @{
        long PRIM_type;                 /* always T_UNITDATA_IND */
        long SRC_length;                /* source addr length - see note in
                                           sec. 1.4 */
        long SRC_offset;                /* source addr offset */
        long OPT_length;                /* options length - see note in sec.
                                           1.4 */
        long OPT_offset;                /* options offset */
@}
@end smallexample

Where @var{PRIM_type} identifies the primitive type.  @var{SRC_length} is the
length of the source address and @var{SRC_offset} is the offset from the
beginning of the M_PROTO message block where the source address begins.
Similarly, @var{OPT_length} and @var{OPT_offset} describe the location of the
requested options associated with the primitive. The proper alignment of the
source address and options in the M_PROTO message block is not guaranteed.

@node T_UDERROR_IND
@subsubsection T_UDERROR_IND - unitdata error indication.

This primitive indicates to the transport user that a datagram with the
specified destination address and options produced an error. The format of this
message is one M_PROTO message block. The format of the M_PROTO message block is
as follows:

@smallexample
struct T_uderror_ind @{
        long PRIM_type;                 /* always T_UDERROR_IND */
        long DEST_length;               /* destination addr length - see note
                                           in sec. 1.4 */
        long DEST_offset;               /* destination addr offset */
        long OPT_length;                /* options length - see note in sec.
                                           1.4 */
        long OPT_offset;                /* options offset */
        long ERROR_type;                /* error type */
@}
@end smallexample

Where @var{PRIM_type} identifies the primitive type. @var{DEST_length} is the
length of the destination address and @var{DEST_offset} is the offset from the
beginning of the M_PROTO message block where the destination address begins.
Similarly, @var{OPT_length} and @var{OPT_offset} describe the location of the
requested options associated with the primitive. @var{ERROR_type} defines the
protocol dependent error code. The proper alignment of the destination address
and options in the M_PROTO message block is not guaranteed.

@page
@node Note about Structure Elements
@section Note about Structure Elements

Although the structure elements in the Transport Provider Interface are declared
as long data types, the value the transport provider assigns to those elements
that refer to this note must not be greater than the maximum value of an int
data type because the corresponding user level structure element is declared as
an int.

@page
@node Overview of Error Handling Capabilities
@section Overview of Error Handling Capabilities

@menu
* Non-fatal Errors::
* Fatal Errors::
@end menu

There are two error handling facilities available to the transport user: one to
handle non-fatal errors and one to handle fatal errors.

@node Non-fatal Errors
@subsection Non-fatal Errors

The non-fatal errors are those that a transport user can correct, and are
reported in the form of an error acknowledgement to the appropriate primitive in
error. Only those primitives which require acknowledgements may generate a
non-fatal error acknowledgement. These acknowledgements always report a
syntactical error in the specified primitive when the transport provider
receives the primitive. The primitive descriptions above define those primitives
and rules regarding the acknowledgement of them. These errors are reported to
the transport user via the T_ERROR_ACK primitive, and give the transport user the
option of reissuing the transport service primitive that caused the error. The
T_ERROR_ACK primitive also indicates to the transport user that no action was
taken by the transport provider upon receipt of the primitive which caused the
error. These errors do not change the state of the transport service interface
as seen by the transport user. The state of the interface after the issuance of
a T_ERROR_ACK primitive should be the same as it was before the transport
provider received the interface primitive that was in error. The allowable
errors that can be reported on the receipt of a transport initiated primitive
are presented in the description of the appropriate primitives.

@node Fatal Errors
@subsection Fatal Errors

Fatal errors are those which can not be corrected by the transport user, or
those errors which result in an uncorrectable error in the interface or in the
transport provider.

The most common of these errors are listed under the appropriate primitives. The
transport provider should issue fatal errors only if the transport user can not
correct the condition which caused the error or if the transport provider has no
means of reporting a transport user correctable error. If the transport provider
detects an uncorrectable non-protocol error internal to the transport provider,
the provider should issue a fatal error to the user.

Fatal errors are indicated to the transport user via the STREAMS message type
M_ERROR with the UNIX System error EPROTO. This is the only type of error that
the transport provider should use to indicate a fatal protocol error to the
transport user. The message M_ERROR will result in the failure of all the
operating system service routines on the stream. The only way for a user to
recover from a fatal error is to ensure that all processes close the file
associated with the stream. At that point, the user may reopen the file
associated with the stream.

@page
@node Transport Service Interface Sequence of Primitives
@section Transport Service Interface Sequence of Primitives

The allowable sequence of primitives are described in the state diagrams and
tables in section 4 for both the connection-mode and connectionless-mode
transport services. The following are rules regarding the maintenance of the
state of the interface:

@itemize @bullet

@item It is the responsibility of the transport provider to keep record of the
state of the interface as viewed by the transport user.

@item The transport provider must never issue a primitive that places the
interface out of state.

@item The uninitialized state of a stream is the initial and final state, and it
must be bound (see T_BIND_REQ primitive) before the transport provider may view
it as an active stream.

@item If the transport provider sends a M_ERROR upstream, it should also drop
any further messages received on its write side of the stream. The following
rules apply only to the connection-mode transport services.

@item A transport connection release procedure can be initiated at any time
during the transport connection establishment or data transfer phase.

@item The state tables for the connection-mode transport service providers
include the management of the sequence numbering when a transport provider sends
multiple T_CONN_IND requests without waiting for the response of the previously
sent indication. It is the responsibility of the transport providers not to
change state until all the indications have been responded to, therefore the
provider should remain in the indications have been responded to.

@item The only time the state of a transport service interface of a stream may
be transferred to another stream is when it is indicated in a T_CONN_RES
primitive. The following rules then apply to the cooperating streams:

@itemize ---

@item The stream which is to accept the current state of the interface must be
bound to an appropriate protocol address and must be in the idle state.

@item The user transferring the current state of a stream must have correct
permissions for the use of the protocol address bound to the accepting stream.

@item The stream which transfers the state of the transport interface must be
placed into an appropriate state after the completion of the transfer.

@end itemize

@end itemize

@page
@node Precedence of Transport Interface Primitives on a Stream
@section Precedence of Transport Interface Primitives on a Stream

The following rules apply to the precedence of transport interface primitives
with respect to their position on a stream:@footnote{The stream queue which
contains the transport user initiated primitives is referred to as the stream
write queue. The stream queue which contains the transport provider initiated
primitives is referred to as the stream read queue.}

@itemize @bullet

@item The transport provider has responsibility for determining precedence on
its stream write queue, as per the rules in section 5. The appendix specifies
the rules for precedence for both the connection-mode and connectionless-mode
transport services.

@item The transport user has responsibility for determining precedence on its
stream read queue, as per the rules in section 5.

@item All primitives on the stream are assumed to be placed on the queue in the
correct sequence as defined above. The following rules apply only to the
connection-mode transport services.

@item There is no guarantee of delivery of user data once a T_DISCON_REQ
primitive has been issued.

@end itemize

@page
@node Rules for Flushing Queues
@section Rules for Flushing Queues

The following rules pertain to flushing the stream queues. No other flushes
should be needed to keep the queues in the proper condition.

@itemize @bullet

@item The transport providers must be aware that they will receive M_FLUSH
messages from upstream. These flush requests are issued to ensure that the
providers receive certain messages and primitives. It is the responsibility of
the providers to act appropriately as deemed necessary by the providers.

@item The transport provider must send up a M_FLUSH message to flush both the
read and write queues after receiving a successful T_UNBIND_REQ message and
prior to issuing the T_OK_ACK primitive.

@end itemize

The following rules pertain only to the connection-mode transport providers.

@itemize @bullet

@item If the interface is in the T_DATA_XFER, T_WIND_ORDREL or T_WACK_ORDREL
state, the transport provider must send up a M_FLUSH message to flush both the
read and write queues before sending up a T_DISCON_IND.

@item If the interface is in the T_DATA_XFER, T_WIND_ORDREL or T_WACK_ORDREL
state, the transport provider must send up a M_FLUSH message to flush both the
read and write queues after receiving a successful T_DISCON_REQ message and
before issuing the T_OK_ACK primitive.

@end itemize

@node Mapping of Transport Primitives to OSI
@chapter Mapping of Transport Primitives to OSI

The following table maps those transport primitives as seen by the transport
provider to the @dfn{STREAMS} message types used to realize the primitives and
to the ISO IS 8072 and IS8072/DAD1 transport service definition primitives.

@cartouche
@image{tpi_fig2}
@center @b{Figure 2.   Mapping ISO IS 8072 and IS 8072/DAD1 to}
@center @b{Kernel-level Transport Service Primitives}
@end cartouche

@node Allowable Sequence of Transport Service Primitives
@chapter Allowable Sequence of Transport Service Primitives

The following tables describe the possible events that may occur on the
interface and the possible states as viewed by the transport user that the
interface may enter due to an event. The events map directly to the transport
service interface primitives as described in section 2.

@cartouche
@image{tpi_fig3}
@center @b{Figure 3.  Kernel Level Transport Interface States}
@end cartouche

@page
@subsubheading Variables and Outputs

The following describes the variables and outputs used in the state tables.

@cartouche
@image{tpi_fig4}
@center @b{Figure 4.  State table Variables}
@end cartouche

@cartouche
@image{tpi_fig5}
@center @b{Figure 5. State Table Outputs}
@end cartouche

@page
@subsubheading Outgoing Events

The following outgoing events are those which are initiated from the transport
service user. They either make requests of the transport provider or respond to
an event of the transport provider.

@cartouche
@image{tpi_fig6}
@center @b{Figure 6.  Kernel Level Transport Interface Outgoing Events}
@end cartouche

@page
@subsubheading Incoming Events

The following incoming events are those which are initiated from the transport
provider.  They are either confirmations of a request or are indications to the
transport user that an event has occurred.

@cartouche
@image{tpi_fig7}
@center @b{Figure 7.  Kernel Level Transport Interface Incoming Events}
@end cartouche

@page
@subsubheading Transport Service State Tables

The following tables describes the possible next states the interface may enter
given a current state and event.

The contents of each box represent the next state given the current state
(column) and the current incoming or outgoing event (row). An empty box
represents a state/event combination that is invalid. Along with the next state,
each box may include an action.  The transport provider must take the specific
actions in the order specified in the state table.

@cartouche
@image{tpi_fig8}
@center @b{Figure 8.  Initialization State Table}
@end cartouche

@page
@cartouche
@image{tpi_fig9}
@center @b{Figure 9.  Connection/Release/Data-Transfer State Table}
@center @b{for Connection Oriented Service}
@end cartouche

@cartouche
@image{tpi_fi10}
@center @b{Figure 10.  Data-Transfer State Table for Connectionless Service}
@end cartouche

@node Transport Primitive Precedence
@chapter Transport Primitive Precedence

The following describes the precedence of the transport primitives for both the
stream@footnote{The stream queue which contains the transport user initiated
primitives is referred to as the stream write queue. The stream queue which
contains the transport provider initiated primitives is referred to as the
stream read queue.} write and read queues.

@cartouche
@image{tpi_fi11}
@center @b{Figure 11.  Stream Write Queue Precedence Table}
@end cartouche

@page
@cartouche
@image{tpi_fi12}
@center @b{Figure 12.  Stream Read Queue Precedence Table}
@end cartouche

@node Index
@unnumbered Index

@printindex cp

@page
@shortcontents
@page
@contents
@bye
